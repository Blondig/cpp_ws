### 1.STL的大、小、相等概念
- **STL中关联容器内部的元素是排序的**。STL中的许多算法也涉及排序、查找。这些容器和算法都需要对元素进行比较，有的比较是否相等，有的比较元素大小。
- 在STL中，**默认情况下，比较大小是通过<运算符进行的，和>运算符无关**。在STL中提到“大”、“小”的概念时，以下三个说法是等价的：
    - x 比 y 小
    - 表达式x<y为真
    - y 比 x 大
- 注意：**y比x大意味着x<y为真，而不是y>x为真**。y>x的结果如何并不重要，甚至y>x是没定义的都没有关系
- 在STL中，**x和y相等也往往不等价于x==y为真**。对于在未排序的区间上进行的算法，如顺序查找算法find，查找过程中比较两个元素是否相等用的是==运算符；但是对于在排好序的区间上进行查找、合并等操作的算法（如折半查找算法binary_search，关联容器自身的成员函数 find）来说，**x和y相等是与x<y和y<x同时为假等价的，与==运算符无关**。看上去x<y和y<x同时为假就应该和x==y为真等价，其实不然。例如下面的class A：
    ```
        class A{
                int v;
            public:
                bool operator< (const A &a) const{
                    return false;
                }
        };
    ```
- 可以看到，对任意两个类A的对象x、y，x<y和y<x都是为假的。也就是说，对STL的关联容器和许多算法来说，任意两个类A的对象都是相等的，这与==运算符的行为无关。
- 综上所述，**使用STL中的关联容器和许多算法时，往往需要对<运算符进行适当的重载，使得这些容器和算法可以用<运算符对所操作的元素进行比较**。最好将<运算符重载为全局函数，因为在重载为成员函数时，在有些编译器上会出错（由其STL源代码的写法导致）。