### 1.C++中的字节对齐
- 字节对齐解释：
    - 现代计算机中内存空间都是按照字节划分的，从理论上来说对任何类型变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候，经常在特定的内存地址访问，这就需要对各种数据类型按照一定的规则在空间上排列，而不是顺序的一个接一个的排列，这就是对齐。
- 字节对齐的原因和作用：
    - 各个硬件平台对存储空间的处理上有很大的不同，一些平台对某些特定类型的数据只能从某些特定的地址开始存储。比如，有些架构的CPU在访问一个没有进行对齐的变量的时，会发生错误。那么在这种架构下编程必须保证字节对齐。其他平可能没有这种情况，但是最常见的是如果不按照适合其平台要求对数据进行对齐存放，那么会在存储效率上带来损失。比如，有些平台每次都是从偶数地址开始；如果一个int类型(假设是32位系统)变量，如果存储在偶地址开始的地方，那么一个读周期就可以读出32bit，而如果存放在奇地址开始的地方，就需要读两个周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据，显然在读取效率上下降很多。
### 2.具体实例
    ```
        #include "iostream"

        using namespace std;


        struct student_info{
            char name;
            int age;
            int number;
            char add;
        };

        int main(){
            cout << sizeof(student_info) << endl;
            return 0;
        }
    ```
- 对结构体student_info使用sizeof()会出现什么结果？也许你会这样求:sizeof(student_info) = sizeof(char) + sizeof(int) + sizeof(int) + sizeof(char) = 10。但是实际结果是16,原因就是VC对变量存储做了一个特殊处理。为了提高CPU的存储速度，VC对一些变量的起始地址做了“对齐”处理。 在默认情况下，**VC规定各成员变量存放的起始地址相对于结构的起始地址的偏移量必须是该变量的类型所占用的字节数的倍数**。
### 3.常用数据类型的对齐方式(32机系统)
| 类型 | 对齐方式(变量存放的起始地址相对于结构的起始地址的偏移量) |
| :------| :------: |
| char | 偏移量必须是sizeof(char)即1的倍数 |
| int | 偏移量必须是sizeof(int)即4的倍数 |
| float | 偏移量必须是sizeof(float)即4的倍数 |
| double | 偏移量必须是sizeof(double)即8的倍数 |
| short | 偏移量必须是sizeof(short)即2的倍数 |
- 各成员变量在存放的时候根据在结构中出现的顺序依次申请空间，同时按照上面的对齐方式调整位置，空缺的字节VC会自动填充。同时VC为了确保结构的大小为结构的字节边界数（即该结构中占用最大空间的类型所占用的字节数）的倍数，所以在为最后一个成员变量申请空间后，还会根据需要自动填充空缺的字节。 
- 上面实例的分析过程：
    - 先为第一个成员name分配空间，其起始地址跟结构的起始地址相同（刚好偏移量0刚好为sizeof(name)的倍数），该成员变量占用sizeof(name)=1个字节；
    - 接下来为第二个成员age分配空间，这时下一个可以分配的地址对于结构体的起始地址的偏移量为1，不是sizeof(int)的倍数，为了满足对齐方式对偏移量的约束问题，VC自动填充3个字节（这三个字节没有放什么东西），这是下一个成员变量可以分配的。
    - 然后，为第三个成员number分配空间，这时下一个可以分配的地址对于结构体的起始地址的偏移量是5，不是sizeof(int)的倍数，为了满足对齐方式对偏移量的约束问题，VC字典填充3个字节（这三个字节没有放什么东西），这是下一个成员变量可以分配的。
    - 最后，为第四个成员add分配空间，这时下一个可以分配的地址对于结构体的起始地址的偏移量是8，刚好是sizeof(char)的倍数，最后总的占用空间是:1+4+3+4+3+1 = 16,这时整个结构的成员变量已经都分配了空间,刚好为结构的字节边界数(即结构中占用最大空间的类型所占用的字节数sizeof(int)=4)的倍数，所以没有空缺的字节需要填充。其中有6个字节是VC自动填充的，没有放任何有意义的东西。 
- 一个新的实例：
    ```
        struct myStruct{
            char a;  // 偏移量为0，满足对齐方式，a占用1个字节； 
            double b;  // 下一个可用的地址的偏移量为1，不是sizeof(double)=8的倍数，需要补足7个字节才能使偏移量变为8（满足对齐方式），因此VC自动填充7个字节，dda1存放在偏移量为8的地址上，它占用8个字节。 
            int c; // 下一个可用的地址的偏移量为16，是sizeof(int)=4的倍数，满足int的对齐方式，所以不需要VC自动填充，type存放在偏移量为16的地址上，它占用4个字节
        };  // 所有成员变量都分配了空间，空间总的大小为1+7+8+4=20，不是结构的节边界数（即结构中占用最大空间的类型所占用的字节数sizeof(double)=8）的倍数，所以需要填充4个字节，以满足结构的大小为sizeof(double)=8的倍数。 

        int main(){
            cout << "sizeof(student_info): " << sizeof(student_info) << endl;
            cout << "sizeof(myStruct): " << sizeof(myStruct) << endl;
            return 0;
        }
    ```
- 所以该结构总的大小为：sizeof(MyStruct)为1+7+8+4+4=24。其中总的有7+4=11个字节是VC自动填充的，没有放任何有意义的东西。 
![结果.png](https://upload-images.jianshu.io/upload_images/13407176-28c47347b0a597f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
### 4 \#pragma pack(n)来设定变量以n字节对齐方式
- VC对结构的存储的特殊处理确实提高CPU存储变量的速度，但是有时候也带来了一些麻烦，我们也屏蔽掉变量默认的对齐方式，自己可以设定变量的对齐方式。 VC中提供了\#pragma pack(n)来设定变量以n字节对齐方式。**n字节对齐就是说变量存放的起始地址的偏移量**有两种情况：
    - 如果n大于等于该变量所占用的字节数，那么偏移量必须满足默认的对齐方式
    - 如果n小于该变量的类型所占用的字节数，那么偏移量为n的倍数，不用满足默认的对齐方式
- 结构体的总大小也有个约束条件，分下面两种情况：如果n大于所有成员变量类型所占用的字节数，那么结构体的总大小必须为占用空间最大的变量占用的空间数的倍数；否则必须为n的倍数（两者相比，取小）