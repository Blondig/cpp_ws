### 一.C++中运算符重载需要遵循的规则
- 1.并不是所有的运算符都可以重载。能够重载的运算符包括：
    ```
        +  -  *  /  %  ^  &  |  ~  !  =  <  >  +=  -=  *=  /=  %=  ^=  &=  |=  <<  >>  <<=  >>=  ==  !=  <=  >=  &&  ||  ++  --  ,  ->*  ->  ()  []  new  new[]  delete  delete[]  // []是下标运算符，()是函数调用运算符,自增自减运算符的前置和后置形式都可以重载
    ```
- 不能重载的运算符是:
    ```
        长度运算符sizeof、条件运算符: ?、成员选择符.和域解析运算符::不能被重载!
    ```
- 2.重载不能改变运算符的优先级和结合性。假设上一节的complex类中重载了+号和*号，并且c1、c2、c3、c4都是complex类的对象，那么下面的语句：
    ```
        c4 = c1 + c2 * c3;  // 等价于 c4 = c1 + (c2 * c3);  乘法的优先级仍然高于加法，并且它们仍然是二元运算符
    ```
- 3.重载不会改变运算符的用法，原来有几个操作数、操作数在左边还是在右边，这些都不会改变。例如~号右边只有一个操作数，+号总是出现在两个操作数之间，重载后也必须如此。
- 4.**运算符重载函数不能有默认的参数，否则就改变了运算符操作数的个数，这显然是错误的!**
- 5.**运算符重载函数既可以作为类的成员函数，也可以作为全局函数**
    - 将运算符重载函数作为类的成员函数时，二元运算符的参数只有一个，一元运算符不需要参数。之所以少一个参数，是因为这个参数是隐含的。例如，上节的complex类中重载了加法运算符：
        ```
            complex operator+(const complex & A) const;
            c3 = c1 + c2;  // 被转换为 c3 = c1.operator+(c2);  通过this指针隐式的访问c1的成员变量
        ```
    - **将运算符重载函数作为全局函数时，二元操作符就需要两个参数，一元操作符需要一个参数，而且其中必须有一个参数是对象**，好让编译器区分这是程序员自定义的运算符，防止程序员修改用于内置类型的运算符的性质。
        - 例如，下面这样是不对的：
            ```
                int operator+ (int a,int b){
                    return (a-b);
                }
            ```
        - +号原来是对两个数相加，现在企图通过重载使它的作用改为两个数相减， 如果允许这样重载的话，那么表达式4+3的结果是 7 还是 1 呢？显然，这是绝对禁止的。
    - 如果有两个参数，这两个参数可以都是对象，也可以一个是对象，一个是C++内置类型的数据，例如：
        ```
            complex operator+(int a, complex &c){
                return complex(a+c.real, c.imag);
            }
        ```
    - **另外，将运算符重载函数作为全局函数时，一般都需要在类中将该函数声明为友元函数。原因很简单，该函数大部分情况下都需要使用类的private成员。**
- 6.箭头运算符->、下标运算符[ ]、函数调用运算符( )、赋值运算符=只能以成员函数的形式重载