### 1.Cpp中的迭代器
- **要访问顺序容器和关联容器中的元素，需要通过迭代器(iterator)进行**。迭代器是一个变量，相当于容器和操纵容器的算法之间的中介。迭代器可以指向容器中的某个元素，通过迭代器就可以读写它指向的元素,从这一点上看，迭代器和指针类似。
- 迭代器按照定义方式分成以下四种:
    - 正向迭代器，定义方法如下：
        ```
            容器类名::iterator 迭代器名;
        ```
    - 常量正向迭代器，定义方法如下：
        ```
            容器类名::const__iterator 迭代器名;
        ```
    - 反向迭代器，定义方法如下：
        ``` 
            容器类名::reverse_iterator 迭代器名;
        ```
    - 常量反向迭代器，定义方法如下：
        ```
            容器类名::const_reverse_iterator 迭代器名;
        ```
### 2.迭代器用法示例
- **通过迭代器可以读取它指向的元素，\*迭代器名就表示迭代器指向的元素,通过*非常量迭代器*还能修改其指向的元素**。迭代器都可以进行++操作。反向迭代器和正向迭代器的区别在于：
    - 对**正向迭代器进行++操作**时，迭代器会指向容器中的**后一个元素**；
    - 对**反向迭代器进行++操作**时，迭代器会指向容器中的**前一个元素**。
- 实例如下:
    ```
        #include "iostream"
        #include "vector"

        using namespace std;



        int main(){
            // 迭代器用法实例
            vector<int> v;  // v中存放int类型变量的可变长的数组，开始时没有元素
            for(int n=0; n < 5; n++)
                v.push_back(n);  // push_back()成员函数在vector容器尾部添加一个元素
            vector<int>::iterator i;  // 定义正向迭代器
            cout << "正向迭代器遍历容器: ";
            for(i = v.begin(); i!=v.end();++i){  // 用正向迭代器从前往后遍历容器,使用前置++,不使用后置++,因为这将会降低运算时间，原因是++运算符的重载！后置++会多生成一个局部对象temp!
                cout << *i << " ";   // *n就是迭代器n指向的元素
                *i *= 2;   // 每个元素变为原来的2倍
            }
            cout << endl;
            // 用反向迭代器遍历容器
            cout << "反向迭代器遍历容器: ";
            vector<int>::reverse_iterator j;
            for(j=v.rbegin(); j != v.rend();++j)   // 用反向迭代器从后往前遍历容器
                cout << *j << " ";
            cout << "-------------------------------------\n";

            return 0;
        }
    ```
### 3.迭代器的功能分类
- 不同容器的迭代器，其功能强弱有所不同。容器的迭代器的功能强弱，决定了该容器是否支持STL中的某种算法。例如，排序算法需要通过随机访问迭代器来访问容器中的元素，因此有的容器就不支持排序算法。**常用的迭代器按功能强弱**分为输入、输出、正向、双向、随机访问五种，这里只介绍常用的三种。
    - 正向迭代器: 假设p是一个正向迭代器，则p支持以下操作：++p，p++，*p。此外，两个正向迭代器可以互相赋值，还可以用==和!=运算符进行比较。
    - 双向迭代器: 双向迭代器具有正向迭代器的全部功能。除此之外，若p是一个双向迭代器，则--p和p--都是有定义的。--p使得p朝着和++p相反的方向移动。
    - 随机访问迭代器: 随机访问迭代器具有双向迭代器的全部功能。若p是一个随机访问迭代器，i是一个整型变量或常量，则p还支持以下操作：
        - p+=i：使得p往后移动i个元素
        - p-=i：使得p往前移动i个元素
        - p+i：**返回p后面第i个元素的迭代器**
        - p-i：返回p前面第i个元素的迭代器
        - p[i]：返回p后面第i个元素的引用
    - 此外，两个随机访问迭代器p1、p2 还可以用 <、>、<=、>= 运算符进行比较。p1 < p2的含义是：p1经过若干次（至少一次）++操作后，就会等于p2,其他比较方式的含义与此类似。对于两个随机访问迭代器p1、p2，表达式p2-p1也是有定义的，其返回值是p2所指向元素和p1所指向元素的序号之差（**也可以说是p2和p1之间的元素个数减一**）。
  ![不同容器的迭代器的功能.png](https://upload-images.jianshu.io/upload_images/13407176-8617c5502211eabd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 实例如下:
    ```
        // 迭代器的功能分类
        vector<int> v1(10);   // v1初始化成有10个元素
        for(int i = 0; i < v.size(); ++i)  // size()返回元素的个数
            cout << "v1[" << i << "] = " << v1[i] << " ";
        cout << endl;
        vector<int>::iterator i1;
        for(i1 = v1.begin(); i1 != v1.end(); ++i1)  // 用 != 比较两个迭代器
            cout << *i1;
        cout << endl;
        for(i1 = v1.begin(); i1 < v1.end(); ++i1)  // 用 < 比较两个迭代器
            cout << *i1;
        cout << endl;
        i1 = v.begin();
        while(i1 < v.end()){  // 间隔一个输出
            cout << *i1;
            i1 += 2;   // 随机访问迭代器支持 "+= 整数"  的操作
        }
        cout << endl;
    ```
- list容器的迭代器是双向迭代器。假设v和i的定义如下：
    ```
        list<int> l;
        list<int>::const_iterator i
    ```
- 则以下代码是合法的：
    ```
        for(i = l.begin(); i != l.end(); ++i)
            cout << *l << " ";
    ```
- 因为双向迭代器不支持用“<”进行比较,list不支持随机访问迭代器的容器，也不支持用下标随机访问其元素。以下代码则不合法：
    ```
        for(i = l.begin(); i < l.size(); ++i)
            cout << l[i];
        for(i = l.begin(); i < l.end(); ++i)
            cout << *l << endl;
    ```
- 在C++中，数组也是容器。**数组的迭代器就是指针，而且是随机访问迭代器**。例如，对于数组int a[10]，int * 类型的指针就是其迭代器。则a、a+1、a+2都是a的迭代器。
### 4.迭代器的辅助函数
- STL中有用于**操作迭代器**的三个**函数模板**，它们是：
    - advance(p, n)：使迭代器p向前或向后移动n个元素
    - distance(p, q)：计算两个迭代器之间的距离，即迭代器p经过多少次++操作后和迭代器q相等。如果调用时p已经指向q的后面，则这个函数会陷入死循环。
    - iter_swap(p, q)：用于交换两个迭代器p、q指向的值
- **要使用上述模板，需要包含头文件algorithm**。下面的程序演示了这三个函数模板的用法:
    ```
        #include "iostream"
        #include "vector"
        #include "list"
        #include "algorithm"  // 要使用操作迭代器的函数模板，需要包含此文件!!

        using namespace std;
        int main(){
            // 迭代器的辅助函数
            int a[5] = {6, 66, 666, 6666, 0};
            list<int> lst(a, a+5);
            list<int>::iterator p = lst.begin();  // 迭代器p，类似于一个指针
            advance(p, 2);    // p向后移动两个元素，指向666
            cout << *p << endl;  // 输出666
            advance(p, -1);  // p向前移动一个元素，指向66
            cout << *p << endl;  // 输出66
            list<int>::iterator q = lst.end();
            q--;  // q指向5
            cout << distance(p, q) << endl;  // 输出3
            iter_swap(p, q);  // 序号从1开始，交换2号和5号元素
            for(p = lst.begin(); p != lst.end(); ++p)
                cout << *p << " ";
            return 0;
        } 
    ```