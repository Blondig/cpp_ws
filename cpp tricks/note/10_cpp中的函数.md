### 1.Cpp中的函数
- 函数是一组一起执行一个任务的语句。每个C++ 序都至少有一个函数，即主函数main() ，所有简单的程序都可以定义其他额外的函数。
- 函数声明告诉编译器函数的名称、返回类型和参数;函数定义提供了函数的实际主体
- C++标准库提供了大量的程序可以调用的内置函数。例如，函数strcat()用来连接两个字符串，函数 memcpy()用来复制内存到另一个位置。函数还有很多叫法，比如方法、子例程或程序，等等.
### 2.定义函数
- C++中定义函数的一般形式如下：
    ```
        返回值类型 函数名(形参列表){
            函数体
        }
    ```
- 在C++中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：
    - 返回类型：一个函数可以返回一个值。返回值类型是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，返回值是关键字void。
    - 函数名称：这是函数的实际名称。函数名和形式参数列表一起构成了函数签名。
    - 参数：参数就像是占位符。当函数被调用时，可以向参数传递一个值，这个值被称为实际参数。形式参数列表包括函数形式参数的类型、顺序、数量。形式参数是可选的，也就是说，函数可能不包含形式参数。
    - 函数主体：函数主体包含一组定义函数执行任务的语句。
    ```
        int maxnum(int num1, int num2);  // 函数声明
        int main(){
            int num1 = 3, num2 = 6;
            int result;
            result = maxnum(num1, num2);  // 调用函数maxnum()
            cout << "两个数之间的最大数是: " << result << endl;
            return 0;
        }


        // 函数定义
        int maxnum(int num1, int  num2){
            if (num1 > num2)
                result = num1
            else
                result = num2;
            return result;
        }
    ```
### 3.函数声明
- 函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。函数声明包括以下几个部分：
    ```
        返回值类型 函数名(形参列表);
    ```
- 针对上面定义的函数maxnum()，以下是函数声明：
    ```
        int maxnum(int num1, int num2);
    ```
- **在函数声明中，参数的名称并不重要，只有参数的类型是必需的**，因此下面也是有效的声明：
    ```
        int maxnum(int, int);
    ```
- **当在一个源文件中定义函数且在另一个文件中调用此函数时，函数声明是必需的。在这种情况下，应该在调用函数的文件顶部声明函数。**
### 4.调用函数
- 创建C++函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达被调用函数的结束括号时，会把程序控制权交还给主程序。调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值，具体见上面的示例程序。
### 5.函数参数
- 如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的**形式参数**。形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。**默认情况下，C++使用传值调用来传递参数**。一般来说，这意味着被调用函数内的代码不能改变用于调用函数的实际参数。当调用函数时，有三种向被调用函数传递参数的方式：
![函数参数传递3种方式.png](https://upload-images.jianshu.io/upload_images/13407176-d233bdf69783b19a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 5.1 传值调用
- 传值调用:**把实际参数的实际值复制一份再传给被调用函数的形式参数**。在这种情况下，修改被调用函数内的形式参数不会影响实际参数。默认情况下，C++使用传值调用方法来传递参数。一般来说，这意味着被调用函数内的代码不会改变用于调用函数的实际参数。函数 swap() 定义如下：
    ```
        // 传值调用方式
        void swap(int a, int b){
            int temp;
            temp = a;
            a = b;
            b = temp;
        }
        // 1 传值调用
        int a = 4, b = 40;
        cout << "交换前的a, b值: " << "a = " << a << ",b = " << b << endl;
        swap(a, b);  // 传值调用只是形参从实参那复制了一份实参的值，被调用函数内的代码不会改变用于调用函数的实际参数
        cout << "交换后的a, b值: " << "a = " << a << ",b = " << b << endl;
    ```
- 5.2 指针调用
- 指针调用:**把实际参数的地址复制给被调用函数中的形式参数**。在被调用函数中，从实际参数那复制过来的地址可以用于访问调用中要用到的实际参数。这意味着，**修改形式参数会影响实际参数**。
- 按指针传递值，参数指针被传递给函数，就像传值给函数一样。因此相应地，在下面的函数swap1()中，需要声明函数形式参数为指针类型，该被调用函数用于交换参数所指向的两个整数变量的值。
    ```
        // 指针传递方式
        void swap1(int *a, int *b){
            int temp;
            temp = *a;
            *a = *b;
            *b = temp;
        }
         // 2 指针调用
        int x = 4, y = 40;
        cout << "交换前的x, y值: " << "x = " << x << ",y = " << y << endl;
        swap1(&x, &y); // 实际参数将实际值的地址复制后再传给形式参数，形式参数获得地址后，在被调用函数的内部可以通过传进来的地址访问调用中用到的实际参数，修改形式参数会影响实际参数！
        cout << "交换后的x, y值: " << "x = " << x << ",y = " << y << endl;
    ```
- 5.3 引用调用
- 引用调用: **把实际参数的引用的地址复制给形式参数**。在被调用函数内，该引用用于访问调用中要用到的实际参数。这意味着，**修改形式参数会影响实际参数**。
- 按引用传递值，即实际参数的引用被传递给被调用函数，就像传递其他值给被调用函数一样。因此，在下面的函数swap2()中，需要声明函数参数为引用类型，该函数用于交换参数所指向的两个整数变量的值。
    ```
        // 引用传递方式
        void swap2(int &a, int &b){
            int temp;
            temp = a;
            a = b;
            b = temp;
        }
        // 3 引用调用
        int m = 4, n = 40;
        cout << "交换前的m, n值: " << "m = " << m << ",n = " << n << endl;
        swap2(m, n); // 将实参的引用的地址复制了一份传给形参,形式参数获得实际参数引用的地址后，在被调用函数的内部可以通过传进来的实际参数的引用的地址访问调用中用到的实际参数，修改形式参数会影响实际参数！
        cout << "交换后的m, n值: " << "m = " << m << ",n = " << n << endl;
    ```
### 6.Lambda函数与表达式
- C++11提供了对匿名函数的支持,称为Lambda函数(也叫Lambda表达式)。Lambda表达式把函数看作对象。Lambda表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。Lambda 表达式本质上与函数声明非常类似,Lambda表达式具体形式如下:
```
    [capture](parameters) mutable ->return-type{statement}
例如：
    [](int a, int b) -> int { return a + b; };
```
- 参数介绍:
    - [capture]：捕捉列表。捕捉列表总是出现在lambda表达式的开始处。事实上，[]是lambda引出符。编译器根据该引出符判断接下来的代码是否是lambda函数。捕捉列表能够捕捉上下文中的变量供lambda函数使用。
    - (parameters)：参数列表。与普通函数的参数列表一致。如果不需要参数传递，则可以连同括号()一起省略。
    - mutable：mutable修饰符。默认情况下，lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。
    - ->return_type：返回类型。用追踪返回类型形式声明函数的返回类型。出于方便，不需要返回值的时候也可以连同符号->一起省略。此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导。
    - {statement}：函数体。内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。在lambda函数的定义式中，参数列表和返回类型都是可选部分，而捕捉列表和函数体都可能为空，C++中最简单的lambda函数只需要声明为：[]{};
```
   // 定义一个简单的lambda表达式
	auto basicLamda = [] {cout << "hello world!" << endl; };
	basicLamda();  // 调用
	// 如果需要参数，那么就要像函数那样，放在圆括号里面，如果有返回值，返回类型要放在->后面，即拖尾返回类型
	// 当然你也可以忽略返回类型，lambda会帮你自动推断出返回类型
	auto add = [](int a, int b) -> int {return a + b; };
	int result = add(4, 5);
	cout << "result = " << result << endl;
	// 自动推断出返回类型
	auto multiply = [](int a, int b) {return a * b; };
	int result1 = multiply(5, 6);
	cout << "result1 = " << result1 << endl;
```
- 在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。C++变量传递有传值和传引用的区别。可以通过前面的[]来指定：
    - []      // 沒有定义任何变量。使用未定义变量会引发错误
    - [x, &y] // x以传值方式传入（默认），y以引用方式传入
    - [&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用
    - [=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用
    - [&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用
    - [=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用
- 对于[=]或[&]的形式，lambda表达式可以直接使用this指针。但是，对于[]的形式，如果要使用this指针，必须显式传入：[this]() { this->someFunc(); }();
    ```
        #include "iostream"

        using namespace std;



        class Test{
        public:
            void hello(){
                cout << "test hello!\n";
            };
            void lambda(){
                auto fun = [this]{ // 捕获了 this 指针
                this->hello(); 
                }; // 这里 this 调用的就是 class Test 的对象了
                fun();
            }
        };


        int main(){
            // 定义一个简单的lambda表达式
            auto basicLamda = [] {cout << "hello world!" << endl; };
            basicLamda();  // 调用
            // 如果需要参数，那么就要像函数那样，放在圆括号里面，如果有返回值，返回类型要放在->后面，即拖尾返回类型
            // 当然你也可以忽略返回类型，lambda会帮你自动推断出返回类型
            auto add = [](int a, int b) -> int {return a + b; };
            int result = add(4, 5);
            cout << "result = " << result << endl;
            // 自动推断出返回类型
            auto multiply = [](int a, int b) {return a * b; };
            int result1 = multiply(5, 6);
            cout << "result1 = " << result1 << endl;
            // 1、什么也不捕获，或者是故意不用 Lambda 函数外部的变量
            int  i = 1024;
            // auto f = []{cout << "i = " << i << endl; }; 报错!应该使用了lambda函数外部的变量
            auto f = [=] { cout << "i = " << i << endl; };  // 使用传值的方式使用外lambda函数外部的变量i
            f();  // 调用函数
            // 2、引用捕捉
            int i1 = 666;
            cout << "变量i1的引用: " << &i1 << endl;
            auto f1 = [&] { cout << "变量i1的引用: " << &i1 << endl; };
            f1();
            // 3、复制并引用捕获
            int i2 = 777, j2 = 888;
            cout << "i2 = " << i2 << endl;
            cout << "j2 = " << j2 << endl;
            auto f2 = [=, &i2] { cout << "i2 = " << &i2 << " ,j2 = " << &j2 << endl; };  // 默认拷贝外部所有变量，但引用变量i2
            f2();
            // 4、指定引用或复制
            int i3 = 444, j3 = 555;
            cout << "外部变量i3 = " << i3 << " i3的地址是: " << &i3 << endl;
            auto f3 = [i3] { cout << "内部变量i3 = " << i3 << " i3的地址是: " << &i3 << endl; };
            f3();
            // 5、捕获this指针
            Test t;
            t.lambda();
            return 0;
        }

    ```