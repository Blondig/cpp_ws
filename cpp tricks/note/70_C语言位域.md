### 1.C语言中的位域详解
- 出现原因：有些数据在存储时并不需要占用一个完整的字节，只需要占用一个或几个二进制位即可。例如开关只有通电和断电两种状态，用0和1表示足以，也就是用一个二进位。正是基于这种考虑，C语言又提供了一种叫做位域的数据结构。
- **在结构体定义时，可以指定某个成员变量所占用的二进制位数（Bit），这就是位域**。请看下面的例子：
    ```
        struct bs{
            unsigned m;
            unsigned n: 4;
            unsigned char ch :6;
        }
    ```
- 符号说明：**:后面的数字用来限定成员变量占用的位数。成员m没有限制，根据数据类型即可推算出它占用4个字节的内存。成员n、ch被:后面的数字限制，不能再根据数据类型计算长度，它们分别占用 4、6位的内存**。n、ch的取值范围非常有限，数据稍微大些就会发生溢出，请看下面的例子：
    ```
        #include <stdio.h>

        int main(){
            struct bs{
                unsigned m;
                unsigned n:4;
                unsigned char ch: 6;
            } a={0xad, 0xE, '$'};
            // 第一次输出
            printf("%#x, %#x, %c\n", a.m, a.n, a.ch);
            // 更改值之后,再次输出
            a.m = 0xb8901c;
            a.n = 0x2d;
            a.ch = 'z';
            printf("%#x, %#x, %c\n", a.m, a.n, a.ch);
            return 0;
        }
    ```
- 运行结果：
    ```
        0xad, 0xe, $
        0xb8901c, 0xd, :
    ```
- 解释：对于n和ch，第一次输出的数据是完整的，第二次输出的数据是残缺的。第一次输出时，n、ch的值分别是0xe、0x24（'$' 对应的 ASCII码为0x24），换算成二进制是1110、100100，都没有超出限定的位数，能够正常输出；第二次输出时，n、ch 的值变为0x2d、0x7a（'z' 对应的ASCII码为0x7a），换算成二进制分别是101101、1111010，都超出了限定的位数。超出部分被直接截去，剩下1101、111010，换算成十六进制为0xd、0x3a（0x3a对应的字符是:）。**C语言标准规定，位域的宽度不能超过它所依附的数据类型的长度。通俗地讲，成员变量都是有类型的，这个类型限制了成员变量的最大长度，:后面的数字不能超过这个长度。**例如，上面的bs，n的类型是unsigned int，长度为4个字节，共计32位，那么n后面的数字就不能超过32；ch的类型是unsigned char，长度为1个字节，共计8位，那么ch后面的数字就不能超过 8。我们可以这样认为，位域技术就是在成员变量所占用的内存中选出一部分位宽来存储数据。**C语言标准还规定，只有有限的几种数据类型可以用于位域。在ANSI C中，这几种数据类型是int、signed int和unsigned int（int默认就是signed int）；到了C99，_Bool也被支持了。**
### 2.位域的存储
- C语言标准并没有规定位域的具体存储方式，不同的编译器有不同的实现，但它们都尽量压缩存储空间。位域的具体存储规则如下：
    - (1) 当相邻成员的类型相同时，如果它们的位宽之和小于类型的sizeof大小时，那么后面的成员紧邻前一个成员存储，直到不能容纳为止；如果它们的位宽之和大于类型的sizeof大小时，那么后面的成员将从新的存储单元开始，其偏移量为类型大小的整数倍。以下面的位域 bs为例：
        ```
            #include <stdio.h>

            int main(){
                struct bs{
                    unsigned m:6;
                    unsigned n:12;
                    unsigned p: 4;
                };
                printf("%d\n", sizeof(struct bs));
                return 0;
            }
        ```
        - 解释：m、n、p的类型都是unsigned int，sizeof的结果为4个字节（Byte），也即32个位（Bit）。m、n、p的位宽之和为6+12+4 =22，小于32，所以它们会挨着存储，中间没有缝隙。如果将成员m的位宽改为22，那么输出结果将会是8，因为22+12=34，大于 32，n会从新的位置开始存储，相对m的偏移量是sizeof(unsigned int)，也即4个字节。如果再将成员p的位宽也改为22，那么输出结果将会是12，三个成员都不会挨着存储。
    - (2)当相邻成员的类型不同时，不同的编译器有不同的实现方案，GCC会压缩存储，而VC/VS不会;请看下面的位域 bs：
        ```
            #include <stdio.h>

            int main(){
                struct bs{
                    unsigned m:6;
                    unsigned char ch:4;
                    unsigned p: 4;
                };
                printf("%d\n", sizeof(struct bs));
                return 0;
            }
        ```
        - 解释：在 GCC 下的运行结果为4，三个成员挨着存储；在VC/VS下的运行结果为12，三个成员按照各自的类型存储（与不指定位宽时的存储方式相同）。
    - (3)如果成员之间穿插着非位域成员，那么不会进行压缩。例如对于下面的 bs：
        ```
            #include <stdio.h>

            int main(){
                struct bs{
                    unsigned m:12;
                    unsigned ch;
                    unsigned p: 4;
                };
                printf("%d\n", sizeof(struct bs));
                return 0;
            }
        ```
        - 解释：unsigned ch是一个非位域成员，所以在各个编译器下sizeof的结果都是12。
- 注意：**通过上面的分析，我们发现位域成员往往不占用完整的字节，有时候也不处于字节的开头位置，因此使用&获取位域成员的地址是没有意义的，C语言也禁止这样做。地址是字节（Byte）的编号，而不是位（Bit）的编号。**
### 2.无名位域
- 位域成员可以没有名称，只给出数据类型和位宽，如下所示：
    ```
        #include <stdio.h>

        int main(){
            struct bs{
                unsigned m:12;
                int : 20;
                unsigned n: 4;
            };
            printf("%d\n", sizeof(struct bs));
            return 0;
        }
    ```
    - 解释：无名位域一般用来作填充或者调整成员位置。因为没有名称，无名位域不能使用。上面的例子中，如果没有位宽为20的无名成员，m、n将会挨着存储，sizeof(struct bs)的结果为4；有了这20位作为填充，m、n将分开存储，sizeof(struct bs)的结果为8。