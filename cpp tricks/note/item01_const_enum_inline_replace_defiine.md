### 1.尽量用const、enum、inline代替宏\#define
- 使用编译器替换预处理器，或许\#define可以不被视为C++语言中的一部分，如下面的代码:
    ```
        #define PI 3.14
    ```
- 名称PI也行从来都没有被编译器看到过，也许在编译器开始处理源码之前，它就已经被预处理器移走了。于是，PI有可能没进入记号表中，所以导致当使用此常量但获得一个编译错误信息时，可能会带来困惑，因为这个错误也会会提到3.14而不是PI；如果PI被定义在一个不是自己写的头文件中，我们可能对3.14的含义一无所知。解决的方法是**使用常量替换上面的宏，见下面的代码**
    ```
        const double Pi = 3.14;  // 宏名一般是大写的
    ```
- 浮点常量Pi肯定会被编译器看到，当然会进入记号表中。此外，使用浮点常量Pi将会比使用宏有较小的代码量，因为使用宏时，会盲目的将宏名称PI替换成3.14，可能导致目标代码出现多份的3.14，但是使用浮点常量绝不会出现相同的情况。
### 2.使用常量代替宏\#define的两种特殊情况
- 2.1 定义常量指针
    - 由于常量定义式通常被放在头文件中，以便被不同的源码所包含。因此，有必要将指针声明为const。例如在头文件中定义一个常量的char\*-base字符串，必须写const两次。下面的情况使用string类的对象会比使用指向常量的常量指针更好。
        ```
            const char* const authorName = "Curry_Coder";  // 指向常量的常量指针
            const string authorName = "Curry_Coder";
        ```
- 2.2 class的专属常量
    - 为了将常量的作用域限制在class中，必须将常量作为class中的一个成员，为了确保常量至多只有一份实体，必须让常量成为静态成员变量。无法使用\#define创建一个class专属常量，因为\#define并不重视作用域，一旦宏被定义后，它就在其后的编译过程中有效。这意味着\#define不仅不能用来定义class专属常量，也不能提供任何的封装，没有访问权限的限制，但const成员变量是可以被封装的。
        ``` 
            class GamePlayer{
                public:
                    static const int NumTurns = 5;  // 常量声明
                    int scores[NumTurns];
            };
        ```
    - 当编译器不允许使用static int class 常量来完成类内部的初值设定时，可以使用所谓的enum hack补偿的做法，即一个属于枚举类型的数值可以当做int类型使用，enum可以让别人无法获得一个指针或引用指向你的某个整数常量，如下面的例子:
        ```
            class GamePlayers{
                private:
                    enum {NumTurns = 5};
                    int socres[NumTurns];
                    // TODO;
            };
        ```
### 3.\#define误用的情况
- 宏看起来像函数，但不会产生函数调用，从而导致额外的开销。下面是带参数的宏，调用函数f:
    ```
        #define CALL_MAX(a, b) f((a) > (b) ? (a):(b))
    ```
- 上面的宏存在太多的缺点，当写出上面的宏时，必须记住为宏中的所有实参加上()，否则别人在表达式中调用这个宏时会带来疑惑。但有时候即使加上(),也会产生不可思议的事情:
    ```
        int a = 5; b = 0;
        CALL_MAX(++a, b);  // a被加2次
        CALL_MAX(++a, b+10);  // a被加1次
    ```
- 使用内联的函数模板解决上面的问题，函数模板接收两个同类型的对象，并以其中较大者调用f，不需要为参数加上括号，如下面的例子：
    ```
        template<typename T>
        inline void call_max(const T &a, const T &b){
            f(a > b) ? a:b;
        }
    ```
### 4.总结
- 对于单纯的常量，最好使用const对象会enum代替\#define宏
- 对于类似于函数的宏，最好改用inline函数替换\#define